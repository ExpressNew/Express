<<<<<<< HEAD
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var Tapable = require("tapable");
var createInnerCallback = require("./createInnerCallback");

function Resolver(fileSystem) {
	Tapable.call(this);
	this.fileSystem = fileSystem;
}
module.exports = Resolver;

Resolver.prototype = Object.create(Tapable.prototype);

Resolver.prototype.resolveSync = function resolveSync(context, request) {
	var err, result, sync = false;
	this.resolve(context, request, function(e, r) {
		err = e;
		result = r;
		sync = true;
	});
	if(!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
	if(err) throw err;
	return result;
};

Resolver.prototype.resolve = function resolve(context, request, callback) {
	if(typeof request === "string") request = this.parse(request);
	this.applyPlugins("resolve", context, request);
	var obj = {
		path: context,
		request: request.path,
		query: request.query,
		directory: request.directory
	};
	function onResolved(err, result) {
		if(err) return callback(err);
		return callback(null, result.path === false ? false : result.path + (result.query || ""));
	}
	onResolved.log = callback.log;
	onResolved.missing = callback.missing;
	if(request.module) return this.doResolve("module", obj, onResolved);
	if(request.directory) return this.doResolve("directory", obj, onResolved);
	return this.doResolve(["file", "directory"], obj, onResolved);
};

Resolver.prototype.doResolve = function doResolve(types, request, callback, noError) {
	if(!Array.isArray(types)) types = [types];
	var stackLine = types.join(" or ") + ": (" + request.path + ") " +
		(request.request || "") + (request.query || "") +
		(request.directory ? " directory" : "") +
		(request.module ? " module" : "");
	var newStack = [stackLine];
	if(callback.stack) {
		newStack = callback.stack.concat(newStack);
		if(callback.stack.indexOf(stackLine) >= 0) {
			// Prevent recursion
			var recursionError = new Error("Recursion in resolving\nStack:\n  " + newStack.join("\n  "));
			recursionError.recursion = true;
			if(callback.log) callback.log("abort resolving because of recursion");
			return callback(recursionError);
		}
	}
	this.applyPlugins("resolve-step", types, request);
	var localMissing = [];
	var missing = callback.missing ? {
		push: function(item) {
			callback.missing.push(item);
			localMissing.push(item);
		}
	} : localMissing;
	var log = [];
	function writeLog(msg) {
		log.push(msg);
	}
	function logAsString() {
		return log.join("\n");
	}
	var currentRequestString = request.request ? request.request + " in " + request.path : request.path;
	if(types.length == 1 && !noError) {
		// If only one type, we can pass the error.
		return this.applyPluginsParallelBailResult(types[0], request, createInnerCallback(function innerCallback(err, result) {
			if(callback.log) {
				for(var i = 0; i < log.length; i++)
					callback.log(log[i]);
			}
			if(err) return callback(err);
			if(result) return callback(null, result);
			if(types[0] === "result") return callback(null, request);
			var error = new Error("Cannot resolve " + types[0] + " '" + request.request + "' in " + request.path);
			error.details = logAsString();
			error.missing = localMissing;
			return callback(error);
		}, {
			log: writeLog,
			missing: missing,
			stack: newStack
		}, "resolve " + types[0] + " " + currentRequestString));
	}
	// For multiple type we list the errors in the details although some of them are not important
	this.forEachBail(types, function(type, callback) {
		this.applyPluginsParallelBailResult(type, request, createInnerCallback(function(err, result) {
			if(!err && result) return callback(result);
			if (err) {
				(err.message || "").split("\n").forEach(function(line) {
					log.push("  " + line);
				});
			}
			callback();
		}, {
			log: writeLog,
			missing: missing,
			stack: newStack
		}, "resolve " + type));
	}.bind(this), function(result) {
		if(callback.log) {
			callback.log("resolve '" + types.join("' or '") + "' " + currentRequestString);
			for(var i = 0; i < log.length; i++)
				callback.log("  " + log[i]);
		}
		if(noError && !result) return callback();
		if(result) return callback(null, result);
		var error = new Error("Cannot resolve '" + types.join("' or '") + "' " + currentRequestString);
		error.details = logAsString();
		error.missing = localMissing;
		return callback(error);
	});
};

Resolver.prototype.parse = function parse(identifier) {
	if(identifier === "") return null;
	var part = {
		path: null,
		query: null,
		module: false,
		directory: false,
		file: false
	};
	var idxQuery = identifier.indexOf("?");
	if(idxQuery == 0) {
		part.query = identifier;
	} else if(idxQuery > 0) {
		part.path = identifier.slice(0, idxQuery);
		part.query = identifier.slice(idxQuery);
	} else {
		part.path = identifier;
	}
	if(part.path) {
		part.module = this.isModule(part.path);
		if(part.directory = this.isDirectory(part.path)) {
			part.path = part.path.substr(0, part.path.length - 1);
		}
	}
	return part;
};

var notModuleRegExp = /^\.$|^\.[\\\/]|^\.\.$|^\.\.[\/\\]|^\/|^[A-Z]:[\\\/]/i;
Resolver.prototype.isModule = function isModule(path) {
	return !notModuleRegExp.test(path);
};

var directoryRegExp = /[\/\\]$/i;
Resolver.prototype.isDirectory = function isDirectory(path) {
	return directoryRegExp.test(path);
};

Resolver.prototype.join = require("memory-fs/lib/join");

Resolver.prototype.normalize = require("memory-fs/lib/normalize");

Resolver.prototype.forEachBail = function(array, iterator, callback) {
	if(array.length == 0) return callback();
	var currentPos = array.length;
	var currentError, currentResult;
	var done = [];
	for(var i = 0; i < array.length; i++) {
		var itCb = (function(i) {
			return function() {
				if(i >= currentPos) return; // ignore
				var args = Array.prototype.slice.call(arguments);
				done.push(i);
				if(args.length > 0) {
					currentPos = i + 1;
					done = done.filter(function(item) {
						return item <= i;
					});
					currentResult = args;
				}
				if(done.length == currentPos) {
					callback.apply(null, currentResult);
					currentPos = 0;
				}
			};
		}(i));
		iterator(array[i], itCb);
		if(currentPos == 0) break;
	}
};

=======
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const util = require("util");

const Tapable = require("tapable/lib/Tapable");
const SyncHook = require("tapable/lib/SyncHook");
const AsyncSeriesBailHook = require("tapable/lib/AsyncSeriesBailHook");
const AsyncSeriesHook = require("tapable/lib/AsyncSeriesHook");
const createInnerContext = require("./createInnerContext");

const REGEXP_NOT_MODULE = /^\.$|^\.[\\\/]|^\.\.$|^\.\.[\/\\]|^\/|^[A-Z]:[\\\/]/i;
const REGEXP_DIRECTORY = /[\/\\]$/i;

const memoryFsJoin = require("memory-fs/lib/join");
const memoizedJoin = new Map();
const memoryFsNormalize = require("memory-fs/lib/normalize");

function withName(name, hook) {
	hook.name = name;
	return hook;
}

function toCamelCase(str) {
	return str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());
}

const deprecatedPushToMissing = util.deprecate((set, item) => {
	set.add(item);
}, "Resolver: 'missing' is now a Set. Use add instead of push.");

const deprecatedResolveContextInCallback = util.deprecate((x) => {
	return x;
}, "Resolver: The callback argument was splitted into resolveContext and callback.");

const deprecatedHookAsString = util.deprecate((x) => {
	return x;
}, "Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.");

class Resolver extends Tapable {
	constructor(fileSystem) {
		super();
		this.fileSystem = fileSystem;
		this.hooks = {
			resolveStep: withName("resolveStep", new SyncHook(["hook", "request"])),
			noResolve: withName("noResolve", new SyncHook(["request", "error"])),
			resolve: withName("resolve", new AsyncSeriesBailHook(["request", "resolveContext"])),
			result: new AsyncSeriesHook(["result", "resolveContext"])
		};
		this._pluginCompat.tap("Resolver: before/after", options => {
			if(/^before-/.test(options.name)) {
				options.name = options.name.substr(7);
				options.stage = -10;
			} else if(/^after-/.test(options.name)) {
				options.name = options.name.substr(6);
				options.stage = 10;
			}
		});
		this._pluginCompat.tap("Resolver: step hooks", options => {
			const name = options.name;
			const stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);
			if(stepHook) {
				options.async = true;
				this.ensureHook(name);
				const fn = options.fn;
				options.fn = (request, resolverContext, callback) => {
					const innerCallback = (err, result) => {
						if(err) return callback(err);
						if(result !== undefined) return callback(null, result);
						callback();
					};
					for(const key in resolverContext) {
						innerCallback[key] = resolverContext[key];
					}
					fn.call(this, request, innerCallback);
				};
			}
		});
	}

	ensureHook(name) {
		if(typeof name !== "string") return name;
		name = toCamelCase(name);
		if(/^before/.test(name)) {
			return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({
				stage: -10
			});
		}
		if(/^after/.test(name)) {
			return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({
				stage: 10
			});
		}
		const hook = this.hooks[name];
		if(!hook) {
			return this.hooks[name] = withName(name, new AsyncSeriesBailHook(["request", "resolveContext"]));
		}
		return hook;
	}

	getHook(name) {
		if(typeof name !== "string") return name;
		name = toCamelCase(name);
		if(/^before/.test(name)) {
			return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({
				stage: -10
			});
		}
		if(/^after/.test(name)) {
			return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({
				stage: 10
			});
		}
		const hook = this.hooks[name];
		if(!hook) {
			throw new Error(`Hook ${name} doesn't exist`);
		}
		return hook;
	}

	resolveSync(context, path, request) {
		let err, result, sync = false;
		this.resolve(context, path, request, {}, (e, r) => {
			err = e;
			result = r;
			sync = true;
		});
		if(!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
		if(err) throw err;
		return result;
	}

	resolve(context, path, request, resolveContext, callback) {
		// TODO remove in enhanced-resolve 5
		// For backward compatiblity START
		if(typeof callback !== "function") {
			callback = deprecatedResolveContextInCallback(resolveContext);
			// resolveContext is a function containing additional properties
			// It's now used for resolveContext and callback
		}
		// END
		const obj = {
			context: context,
			path: path,
			request: request
		};

		const message = "resolve '" + request + "' in '" + path + "'";

		// Try to resolve assuming there is no error
		// We don't log stuff in this case
		return this.doResolve(this.hooks.resolve, obj, message, {
			missing: resolveContext.missing,
			stack: resolveContext.stack
		}, (err, result) => {
			if(!err && result) {
				return callback(null, result.path === false ? false : result.path + (result.query || ""), result);
			}

			const localMissing = new Set();
			// TODO remove in enhanced-resolve 5
			localMissing.push = item => deprecatedPushToMissing(localMissing, item);
			const log = [];

			return this.doResolve(this.hooks.resolve, obj, message, {
				log: msg => {
					if(resolveContext.log) {
						resolveContext.log(msg);
					}
					log.push(msg);
				},
				missing: localMissing,
				stack: resolveContext.stack
			}, (err, result) => {
				if(err) return callback(err);

				const error = new Error("Can't " + message);
				error.details = log.join("\n");
				error.missing = Array.from(localMissing);
				this.hooks.noResolve.call(obj, error);
				return callback(error);
			});
		});
	}

	doResolve(hook, request, message, resolveContext, callback) {
		// TODO remove in enhanced-resolve 5
		// For backward compatiblity START
		if(typeof callback !== "function") {
			callback = deprecatedResolveContextInCallback(resolveContext);
			// resolveContext is a function containing additional properties
			// It's now used for resolveContext and callback
		}
		if(typeof hook === "string") {
			const name = toCamelCase(hook);
			hook = deprecatedHookAsString(this.hooks[name]);
			if(!hook) {
				throw new Error(`Hook "${name}" doesn't exist`);
			}
		}
		// END
		if(typeof callback !== "function") throw new Error("callback is not a function " + Array.from(arguments));
		if(!resolveContext) throw new Error("resolveContext is not an object " + Array.from(arguments));

		const stackLine = hook.name + ": (" + request.path + ") " +
			(request.request || "") + (request.query || "") +
			(request.directory ? " directory" : "") +
			(request.module ? " module" : "");

		let newStack;
		if(resolveContext.stack) {
			newStack = new Set(resolveContext.stack);
			if(resolveContext.stack.has(stackLine)) {
				// Prevent recursion
				const recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
				recursionError.recursion = true;
				if(resolveContext.log) resolveContext.log("abort resolving because of recursion");
				return callback(recursionError);
			}
			newStack.add(stackLine);
		} else {
			newStack = new Set([stackLine]);
		}
		this.hooks.resolveStep.call(hook, request);

		if(hook.isUsed()) {
			const innerContext = createInnerContext({
				log: resolveContext.log,
				missing: resolveContext.missing,
				stack: newStack
			}, message);
			return hook.callAsync(request, innerContext, (err, result) => {
				if(err) return callback(err);
				if(result) return callback(null, result);
				callback();
			});
		} else {
			callback();
		}
	}

	parse(identifier) {
		if(identifier === "") return null;
		const part = {
			request: "",
			query: "",
			module: false,
			directory: false,
			file: false
		};
		const idxQuery = identifier.indexOf("?");
		if(idxQuery === 0) {
			part.query = identifier;
		} else if(idxQuery > 0) {
			part.request = identifier.slice(0, idxQuery);
			part.query = identifier.slice(idxQuery);
		} else {
			part.request = identifier;
		}
		if(part.request) {
			part.module = this.isModule(part.request);
			part.directory = this.isDirectory(part.request);
			if(part.directory) {
				part.request = part.request.substr(0, part.request.length - 1);
			}
		}
		return part;
	}

	isModule(path) {
		return !REGEXP_NOT_MODULE.test(path);
	}

	isDirectory(path) {
		return REGEXP_DIRECTORY.test(path);
	}

	join(path, request) {
		let cacheEntry;
		let pathCache = memoizedJoin.get(path);
		if(typeof pathCache === "undefined") {
			memoizedJoin.set(path, pathCache = new Map());
		} else {
			cacheEntry = pathCache.get(request);
			if(typeof cacheEntry !== "undefined")
				return cacheEntry;
		}
		cacheEntry = memoryFsJoin(path, request);
		pathCache.set(request, cacheEntry);
		return cacheEntry;
	}

	normalize(path) {
		return memoryFsNormalize(path);
	}
}

module.exports = Resolver;
>>>>>>> fe1d9cb169be8371e17b0f68d641d6b37e00413b
