<<<<<<< HEAD
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
function OccurrenceOrderPlugin(preferEntry) {
	if(preferEntry !== undefined && typeof preferEntry !== "boolean") {
		throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.github.io/docs/list-of-plugins.html");
	}
	this.preferEntry = preferEntry;
}
module.exports = OccurrenceOrderPlugin;
OccurrenceOrderPlugin.prototype.apply = function(compiler) {
	var preferEntry = this.preferEntry;
	compiler.plugin("compilation", function(compilation) {
		compilation.plugin("optimize-module-order", function(modules) {
			function entryChunks(m) {
				return m.chunks.filter(function(c) {
					return c.initial;
				}).length;
			}

			function occursInEntry(m) {
				return m.reasons.map(function(r) {
					if(!r.module) return 0;
					return entryChunks(r.module);
				}).reduce(function(a, b) {
					return a + b;
				}, 0) + entryChunks(m);
			}

			function occurs(m) {
				return m.reasons.map(function(r) {
					if(!r.module) return 0;
					return r.module.chunks.length;
				}).reduce(function(a, b) {
					return a + b;
				}, 0) + m.chunks.length;
			}
			modules.sort(function(a, b) {
				if(preferEntry) {
					var aEntryOccurs = occursInEntry(a);
					var bEntryOccurs = occursInEntry(b);
					if(aEntryOccurs > bEntryOccurs) return -1;
					if(aEntryOccurs < bEntryOccurs) return 1;
				}
				var aOccurs = occurs(a);
				var bOccurs = occurs(b);
				if(aOccurs > bOccurs) return -1;
				if(aOccurs < bOccurs) return 1;
				if(a.identifier() > b.identifier()) return 1;
				if(a.identifier() < b.identifier()) return -1;
				return 0;
			});
		});
		compilation.plugin("optimize-chunk-order", function(chunks) {
			function occursInEntry(c) {
				return c.parents.filter(function(p) {
					return p.initial;
				}).length + (c.entry ? 1 : 0);
			}

			function occurs(c) {
				return c.blocks.length + (c.entry ? 1 : 0);
			}
			chunks.forEach(function(c) {
				c.modules.sort(function(a, b) {
					if(a.identifier() > b.identifier()) return 1;
					if(a.identifier() < b.identifier()) return -1;
					return 0;
				});
			});
			chunks.sort(function(a, b) {
				var aEntryOccurs = occursInEntry(a);
				var bEntryOccurs = occursInEntry(b);
				if(aEntryOccurs > bEntryOccurs) return -1;
				if(aEntryOccurs < bEntryOccurs) return 1;
				var aOccurs = occurs(a);
				var bOccurs = occurs(b);
				if(aOccurs > bOccurs) return -1;
				if(aOccurs < bOccurs) return 1;
				if(a.modules.length > b.modules.length) return -1;
				if(a.modules.length < b.modules.length) return 1;
				for(var i = 0; i < a.modules.length; i++) {
					if(a.modules[i].identifier() > b.modules[i].identifier()) return -1;
					if(a.modules[i].identifier() < b.modules[i].identifier()) return 1;
				}
				return 0;
			});
		});
	});
};
=======
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

// TODO webpack 5 remove this plugin
// It has been splitted into separate plugins for modules and chunks
class OccurrenceOrderPlugin {
	constructor(preferEntry) {
		if (preferEntry !== undefined && typeof preferEntry !== "boolean") {
			throw new Error(
				"Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/"
			);
		}
		this.preferEntry = preferEntry;
	}
	apply(compiler) {
		const preferEntry = this.preferEntry;
		compiler.hooks.compilation.tap("OccurrenceOrderPlugin", compilation => {
			compilation.hooks.optimizeModuleOrder.tap(
				"OccurrenceOrderPlugin",
				modules => {
					const occursInInitialChunksMap = new Map();
					const occursInAllChunksMap = new Map();

					const initialChunkChunkMap = new Map();
					const entryCountMap = new Map();
					for (const m of modules) {
						let initial = 0;
						let entry = 0;
						for (const c of m.chunksIterable) {
							if (c.canBeInitial()) initial++;
							if (c.entryModule === m) entry++;
						}
						initialChunkChunkMap.set(m, initial);
						entryCountMap.set(m, entry);
					}

					const countOccursInEntry = (sum, r) => {
						if (!r.module) {
							return sum;
						}
						return sum + initialChunkChunkMap.get(r.module);
					};
					const countOccurs = (sum, r) => {
						if (!r.module) {
							return sum;
						}
						let factor = 1;
						if (typeof r.dependency.getNumberOfIdOccurrences === "function") {
							factor = r.dependency.getNumberOfIdOccurrences();
						}
						if (factor === 0) {
							return sum;
						}
						return sum + factor * r.module.getNumberOfChunks();
					};

					if (preferEntry) {
						for (const m of modules) {
							const result =
								m.reasons.reduce(countOccursInEntry, 0) +
								initialChunkChunkMap.get(m) +
								entryCountMap.get(m);
							occursInInitialChunksMap.set(m, result);
						}
					}

					const originalOrder = new Map();
					let i = 0;
					for (const m of modules) {
						const result =
							m.reasons.reduce(countOccurs, 0) +
							m.getNumberOfChunks() +
							entryCountMap.get(m);
						occursInAllChunksMap.set(m, result);
						originalOrder.set(m, i++);
					}

					modules.sort((a, b) => {
						if (preferEntry) {
							const aEntryOccurs = occursInInitialChunksMap.get(a);
							const bEntryOccurs = occursInInitialChunksMap.get(b);
							if (aEntryOccurs > bEntryOccurs) return -1;
							if (aEntryOccurs < bEntryOccurs) return 1;
						}
						const aOccurs = occursInAllChunksMap.get(a);
						const bOccurs = occursInAllChunksMap.get(b);
						if (aOccurs > bOccurs) return -1;
						if (aOccurs < bOccurs) return 1;
						const orgA = originalOrder.get(a);
						const orgB = originalOrder.get(b);
						return orgA - orgB;
					});
				}
			);
			compilation.hooks.optimizeChunkOrder.tap(
				"OccurrenceOrderPlugin",
				chunks => {
					const occursInInitialChunksMap = new Map();
					const originalOrder = new Map();

					let i = 0;
					for (const c of chunks) {
						let occurs = 0;
						for (const chunkGroup of c.groupsIterable) {
							for (const parent of chunkGroup.parentsIterable) {
								if (parent.isInitial()) occurs++;
							}
						}
						occursInInitialChunksMap.set(c, occurs);
						originalOrder.set(c, i++);
					}

					chunks.sort((a, b) => {
						const aEntryOccurs = occursInInitialChunksMap.get(a);
						const bEntryOccurs = occursInInitialChunksMap.get(b);
						if (aEntryOccurs > bEntryOccurs) return -1;
						if (aEntryOccurs < bEntryOccurs) return 1;
						const aOccurs = a.getNumberOfGroups();
						const bOccurs = b.getNumberOfGroups();
						if (aOccurs > bOccurs) return -1;
						if (aOccurs < bOccurs) return 1;
						const orgA = originalOrder.get(a);
						const orgB = originalOrder.get(b);
						return orgA - orgB;
					});
				}
			);
		});
	}
}

module.exports = OccurrenceOrderPlugin;
>>>>>>> fe1d9cb169be8371e17b0f68d641d6b37e00413b
