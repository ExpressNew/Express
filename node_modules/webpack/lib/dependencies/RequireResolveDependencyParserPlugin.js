<<<<<<< HEAD
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var RequireResolveDependency = require("./RequireResolveDependency");
var RequireResolveContextDependency = require("./RequireResolveContextDependency");
var RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");
var ContextDependencyHelpers = require("./ContextDependencyHelpers");

function RequireResolveDependencyParserPlugin(options) {
	this.options = options;
}

module.exports = RequireResolveDependencyParserPlugin;

RequireResolveDependencyParserPlugin.prototype.apply = function(parser) {
	var options = this.options;
	parser.plugin("call require.resolve", function(expr) {
		return this.applyPluginsBailResult("call require.resolve(Weak)", expr, false);
	});
	parser.plugin("call require.resolveWeak", function(expr) {
		return this.applyPluginsBailResult("call require.resolve(Weak)", expr, true);
	});
	parser.plugin("call require.resolve(Weak)", function(expr, weak) {
		if(expr.arguments.length !== 1) return;
		var param = this.evaluateExpression(expr.arguments[0]);
		var dep;
		if(param.isConditional()) {
			param.options.forEach(function(option) {
				var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, option, weak);
				if(result === undefined) {
					this.applyPluginsBailResult("call require.resolve(Weak):context", expr, option, weak);
				}
			}, this);
			dep = new RequireResolveHeaderDependency(expr.callee.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		} else {
			var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, param, weak);
			if(result === undefined) {
				this.applyPluginsBailResult("call require.resolve(Weak):context", expr, param, weak);
			}
			dep = new RequireResolveHeaderDependency(expr.callee.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		}
	});
	parser.plugin("call require.resolve(Weak):item", function(expr, param, weak) {
		if(param.isString()) {
			var dep = new RequireResolveDependency(param.string, param.range);
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			dep.weak = weak;
			this.state.current.addDependency(dep);
			return true;
		}
	});
	parser.plugin("call require.resolve(Weak):context", function(expr, param, weak) {
		var dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options);
		if(!dep) return;
		dep.loc = expr.loc;
		dep.optional = !!this.scope.inTry;
		dep.weak = weak;
		this.state.current.addDependency(dep);
		return true;
	});
};
=======
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const RequireResolveDependency = require("./RequireResolveDependency");
const RequireResolveContextDependency = require("./RequireResolveContextDependency");
const RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");

class RequireResolveDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		const options = this.options;

		const process = (expr, weak) => {
			if (expr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				for (const option of param.options) {
					const result = processItem(expr, option, weak);
					if (result === undefined) {
						processContext(expr, option, weak);
					}
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			} else {
				const result = processItem(expr, param, weak);
				if (result === undefined) {
					processContext(expr, param, weak);
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processItem = (expr, param, weak) => {
			if (param.isString()) {
				const dep = new RequireResolveDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				dep.weak = weak;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processContext = (expr, param, weak) => {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				param.range,
				param,
				expr,
				options,
				{
					mode: weak ? "weak" : "sync"
				},
				parser
			);
			if (!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.call
			.for("require.resolve")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, false);
			});
		parser.hooks.call
			.for("require.resolveWeak")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, true);
			});
	}
}
module.exports = RequireResolveDependencyParserPlugin;
>>>>>>> fe1d9cb169be8371e17b0f68d641d6b37e00413b
