<<<<<<< HEAD
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var AbstractPlugin = require("../AbstractPlugin");
var RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
var RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
var getFunctionExpression = require("./getFunctionExpression");

module.exports = AbstractPlugin.create({
	"call require.ensure": function(expr) {
		var chunkName = null,
			chunkNameRange = null;
		switch(expr.arguments.length) {
			case 3:
				var chunkNameExpr = this.evaluateExpression(expr.arguments[2]);
				if(!chunkNameExpr.isString()) return;
				chunkNameRange = chunkNameExpr.range;
				chunkName = chunkNameExpr.string;
				// falls through
			case 2:
				var dependenciesExpr = this.evaluateExpression(expr.arguments[0]);
				var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];
				var fnExpressionArg = expr.arguments[1];
				var fnExpression = getFunctionExpression(fnExpressionArg);

				if(fnExpression) {
					this.walkExpressions(fnExpression.expressions);
				}

				var dep = new RequireEnsureDependenciesBlock(expr, fnExpression ? fnExpression.fn : fnExpressionArg, chunkName, chunkNameRange, this.state.module, expr.loc);
				var old = this.state.current;
				this.state.current = dep;
				try {
					var failed = false;
					this.inScope([], function() {
						dependenciesItems.forEach(function(ee) {
							if(ee.isString()) {
								var edep = new RequireEnsureItemDependency(ee.string, ee.range);
								edep.loc = dep.loc;
								dep.addDependency(edep);
							} else {
								failed = true;
							}
						});
					});
					if(failed) {
						return;
					}
					if(fnExpression) {
						if(fnExpression.fn.body.type === "BlockStatement")
							this.walkStatement(fnExpression.fn.body);
						else
							this.walkExpression(fnExpression.fn.body);
					}
					old.addBlock(dep);
				} finally {
					this.state.current = old;
				}
				if(!fnExpression) {
					this.walkExpression(fnExpressionArg);
				}
				return true;
		}
	}
});
=======
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
const RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
const getFunctionExpression = require("./getFunctionExpression");

module.exports = class RequireEnsureDependenciesBlockParserPlugin {
	apply(parser) {
		parser.hooks.call
			.for("require.ensure")
			.tap("RequireEnsureDependenciesBlockParserPlugin", expr => {
				let chunkName = null;
				let chunkNameRange = null;
				let errorExpressionArg = null;
				let errorExpression = null;
				switch (expr.arguments.length) {
					case 4: {
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!chunkNameExpr.isString()) return;
						chunkNameRange = chunkNameExpr.range;
						chunkName = chunkNameExpr.string;
					}
					// falls through
					case 3: {
						errorExpressionArg = expr.arguments[2];
						errorExpression = getFunctionExpression(errorExpressionArg);

						if (!errorExpression && !chunkName) {
							const chunkNameExpr = parser.evaluateExpression(
								expr.arguments[2]
							);
							if (!chunkNameExpr.isString()) return;
							chunkNameRange = chunkNameExpr.range;
							chunkName = chunkNameExpr.string;
						}
					}
					// falls through
					case 2: {
						const dependenciesExpr = parser.evaluateExpression(
							expr.arguments[0]
						);
						const dependenciesItems = dependenciesExpr.isArray()
							? dependenciesExpr.items
							: [dependenciesExpr];
						const successExpressionArg = expr.arguments[1];
						const successExpression = getFunctionExpression(
							successExpressionArg
						);

						if (successExpression) {
							parser.walkExpressions(successExpression.expressions);
						}
						if (errorExpression) {
							parser.walkExpressions(errorExpression.expressions);
						}

						const dep = new RequireEnsureDependenciesBlock(
							expr,
							successExpression ? successExpression.fn : successExpressionArg,
							errorExpression ? errorExpression.fn : errorExpressionArg,
							chunkName,
							chunkNameRange,
							parser.state.module,
							expr.loc
						);
						const old = parser.state.current;
						parser.state.current = dep;
						try {
							let failed = false;
							parser.inScope([], () => {
								for (const ee of dependenciesItems) {
									if (ee.isString()) {
										const edep = new RequireEnsureItemDependency(ee.string);
										edep.loc = dep.loc;
										dep.addDependency(edep);
									} else {
										failed = true;
									}
								}
							});
							if (failed) {
								return;
							}
							if (successExpression) {
								if (successExpression.fn.body.type === "BlockStatement") {
									parser.walkStatement(successExpression.fn.body);
								} else {
									parser.walkExpression(successExpression.fn.body);
								}
							}
							old.addBlock(dep);
						} finally {
							parser.state.current = old;
						}
						if (!successExpression) {
							parser.walkExpression(successExpressionArg);
						}
						if (errorExpression) {
							if (errorExpression.fn.body.type === "BlockStatement") {
								parser.walkStatement(errorExpression.fn.body);
							} else {
								parser.walkExpression(errorExpression.fn.body);
							}
						} else if (errorExpressionArg) {
							parser.walkExpression(errorExpressionArg);
						}
						return true;
					}
				}
			});
	}
};
>>>>>>> fe1d9cb169be8371e17b0f68d641d6b37e00413b
